# 订单数据传递说明

## ✅ 结论：不会影响订单号和金额显示

使用统一收银台**不会影响**订单号生成和订单金额显示，原因如下：

## 📋 订单号生成

### 订单号生成流程

1. **订单号在后端生成**：订单号是在后端API创建订单时生成的，不是在收银台生成的
2. **收银台只接收订单号**：收银台只是接收订单号并显示，不参与订单号生成
3. **流程**：
   ```
   用户下单 → 前端调用后端API → 后端生成订单号 → 返回订单号 → 前端跳转到收银台（携带订单号）
   ```

### 结论

✅ **订单号生成不受影响**，因为：
- 订单号生成逻辑在后端，与收银台无关
- 收银台只是接收和显示订单号
- 使用统一收银台只是改变了跳转目标，不影响订单创建流程

## 💰 订单金额显示

### 收银台获取订单金额的三种方式（多重保障）

#### 方式1：URL参数传递（最可靠）

在跳转到收银台时，通过URL参数传递金额：

```javascript
// 在 HomePage.vue 中跳转时
const baseUrl = `${CASHIER_BASE_URL}/payment/${orderSN}?amount=${totalAmount}&id=${idParam}`
```

**PaymentConfirm.vue 会优先从URL参数读取**：
```javascript
const queryAmount = route.query.amount  // 从URL查询参数获取金额
if (queryAmount) {
  paymentAmount.value = parseFloat(queryAmount).toFixed(2)
  // ✅ 直接使用，最可靠
}
```

#### 方式2：sessionStorage（同域情况下）

在跳转前保存订单数据到 sessionStorage：

```javascript
// 在 HomePage.vue 中
sessionStorage.setItem(`order_${orderSN}`, JSON.stringify({
  orderSN: orderSN,
  actual_price: totalAmount,
  // ... 其他订单数据
}))
```

**收银台会从 sessionStorage 读取**：
```javascript
const cachedData = sessionStorage.getItem(`order_${orderSN}`)
if (cachedData) {
  orderData.value = JSON.parse(cachedData)
  // ✅ 使用缓存数据
}
```

#### 方式3：后端API（备用方案）

如果前两种方式都失败，收银台会从后端API获取：

```javascript
const response = await fetch(`/api/order/${orderSN}`)
const data = await response.json()
// ✅ 从数据库获取订单数据
```

### 结论

✅ **订单金额显示不受影响**，因为：
- 有**三种获取方式**，确保数据不丢失
- URL参数传递是最可靠的方式（不受跨域影响）
- sessionStorage 在同域情况下可用
- 后端API作为最终备用方案

## ⚠️ 注意事项

### 跨域问题

如果收银台和主站**不在同一域名**，需要注意：

#### 问题：sessionStorage 无法跨域共享

- `sessionStorage` 受同源策略限制
- 不同域名之间无法共享 `sessionStorage`

#### 解决方案：使用URL参数传递

**推荐做法**：在跳转到收银台时，通过URL参数传递关键数据：

```javascript
// 在 HomePage.vue 中
const idParam = orderData.value.id || ''
const amount = orderData.value.actual_price || '0'

// 方式1：跳转到收银台时携带参数
window.location.href = `${CASHIER_BASE_URL}/cashier/${orderSN}?amount=${amount}&id=${idParam}`

// 方式2：或者在钱包跳转时携带参数（CashierPage.vue 中已实现）
const baseUrl = `${window.location.origin}/payment/${orderSN}?amount=${amount}&id=${idParam}`
```

**PaymentConfirm.vue 已支持从URL参数读取**：
```javascript
// 优先从URL查询参数获取金额
const queryAmount = route.query.amount
if (queryAmount) {
  paymentAmount.value = parseFloat(queryAmount).toFixed(2)
  // ✅ 不受跨域影响
}
```

### 数据传递最佳实践

#### 推荐配置（跨域安全）

```javascript
// 在 HomePage.vue 中跳转到收银台
const orderSN = 'ORD123456'
const amount = totalAmount.value
const idParam = orderData.value.id || ''

// 1. 尝试保存到 sessionStorage（同域时可用）
try {
  sessionStorage.setItem(`order_${orderSN}`, JSON.stringify(orderDataToSave))
  sessionStorage.setItem(`website_name_${orderSN}`, shopConfig.value.merchant_name || '好旺担保')
} catch (e) {
  console.warn('sessionStorage 保存失败（可能跨域）:', e)
}

// 2. 通过URL参数传递（跨域也可靠）
const params = new URLSearchParams()
if (idParam) params.append('id', idParam)
params.append('amount', amount)
const queryString = params.toString() ? `?${params.toString()}` : ''

// 3. 跳转到统一收银台
window.location.href = `${CASHIER_BASE_URL}/cashier/${orderSN}${queryString}`
```

#### 收银台数据加载优先级

PaymentConfirm.vue 的数据加载优先级（已实现）：

1. ✅ **URL查询参数** `?amount=xxx` （最优先，跨域也可靠）
2. ✅ **sessionStorage** `order_${orderSN}` （同域时可用）
3. ✅ **后端API** `/api/order/${orderSN}` （最终备用）

## 📊 数据流图

### 正常流程（同域）

```
用户下单
  ↓
后端API创建订单 → 返回订单号
  ↓
前端保存订单数据到 sessionStorage
  ↓
跳转到统一收银台（携带订单号）
  ↓
收银台从 sessionStorage 读取订单数据 ✅
  ↓
显示订单号和金额 ✅
```

### 跨域流程

```
用户下单
  ↓
后端API创建订单 → 返回订单号
  ↓
前端通过URL参数传递金额和订单号
  ↓
跳转到统一收银台（URL: /cashier/订单号?amount=金额&id=id参数）
  ↓
收银台从URL参数读取金额 ✅
  ↓
显示订单号和金额 ✅
```

## ✅ 总结

### 订单号生成
- ✅ **不受影响**：订单号在后端生成，收银台只接收和显示

### 订单金额显示
- ✅ **不受影响**：有URL参数、sessionStorage、后端API三种获取方式
- ✅ **跨域安全**：URL参数传递不受跨域限制
- ✅ **多重保障**：即使一种方式失败，还有其他备用方案

### 建议
- ✅ 使用URL参数传递金额（最可靠，跨域也安全）
- ✅ 同时保存到 sessionStorage（同域时可用）
- ✅ 后端API作为最终备用方案

## 🔧 配置检查清单

在配置其他前端网站时，确保：

- [ ] 订单号正确传递（URL路径：`/cashier/${orderSN}`）
- [ ] 金额通过URL参数传递（`?amount=${amount}`）
- [ ] ID参数通过URL参数传递（`&id=${idParam}`）
- [ ] 订单数据保存到 sessionStorage（同域时）
- [ ] 网站名称保存到 sessionStorage（`website_name_${orderSN}`）

按照以上配置，订单号和金额显示都不会有问题！

